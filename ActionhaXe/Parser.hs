-- Parse the tokens generated by Lexer

module ActionhaXe.Parser where

import ActionhaXe.Lexer
import ActionhaXe.Prim
import Text.Parsec
import Text.Parsec.Combinator
import Data.Map (Map)
import qualified Data.Map as Map

data BlockItem = Btok [CToken]
                | Block CToken [BlockItem] CToken
                | ImportDecl CToken CToken
    deriving (Show, Eq)

data AST = Program Package AsState
         | TokenList [CToken]
         | Failure
    deriving (Show, Eq)

data Package = PackageNamed CToken CToken BlockItem
             | Package CToken BlockItem
    deriving (Show, Eq)

{-
data Block = Block CToken [BlockItem] CToken
    deriving (Show, Eq)

data ImportDecl = ImportDecl CToken CToken
    deriving (Show, Eq)
-}

program :: AsParser AST
program = try( do{ x <- package; a <- getState; return $ Program x a} )
      <|> do{ x <- many anytok; return $ TokenList x} -- should always succeed
          <?> "Unknown Error"

package = try( do{ p <- kw "package"; b <- block; return $ Package p b })
      <|> try( do{ p <- kw "package"; i <- ident; b <- block; return $ PackageNamed p i b})

importDecl = do{ k <- kw "import"; s <- sident; return $ ImportDecl k s}

block = do{ l <- op "{"; x <- inBlock; r <- op "}"; return $ Block l x r } 

inBlock = try(do{ lookAhead( op "}"); return [] })
      <|> try(do{ b <- block; return [b] })
      <|> try(do{ x <- manyTill anytok (try(lookAhead (op "}")) <|> try(lookAhead (op "{"))); i <- inBlock; return $ [Btok x]++i })

-- State functions
initSlt :: AsState
initSlt = [Map.empty] -- this is the global state



parseTokens :: String -> [Token] -> AST
parseTokens filename ts = case runParser program initSlt filename ts of
                                   Right a -> a
                                   Left _ -> Failure
