-- Parse the tokens generated by Lexer

module ActionhaXe.Parser where

import ActionhaXe.Lexer
import ActionhaXe.Prim
import Text.Parsec
import Text.Parsec.Combinator

type TList = [Token]
type Parser = Parsec TList ()

type Identifier = (TList, TList)  -- qualifier, name

data TokenBlock = TBtok [CToken]
                | TBblock Block
    deriving (Show, Eq)

data Block = Block CToken [TokenBlock] CToken
    deriving (Show, Eq)

data Package = PackageNamed CToken CToken Block
             | Package CToken Block
    deriving (Show, Eq)

data AST = Program Package
         | TokenList [CToken]
         | Failure
    deriving (Show, Eq)


program :: Parser AST
program = try( do{ x <- package; return $ Program x} )
      <|> do{ x <- many anytok; return $ TokenList x} -- should always succeed
          <?> "Unknown Error"

package = try( do{ p <- kw "package"; b <- block; return $ Package p {- i -} b })
      <|> try( do{ p <- kw "package"; i <- ident; b <- block; return $ PackageNamed p i b})

block = do{ l <- op "{"; x <- inBlock; r <- op "}"; return $ Block l x r } 

inBlock = try(do{ lookAhead( op "}"); return [] })
      <|> try(do{ b <- block; return [TBblock b] })
      <|> try(do{ x <- manyTill anytok (try(lookAhead (op "}")) <|> try(lookAhead (op "{"))); i <- inBlock; return $ [TBtok x]++i })

runParser :: String -> [Token] -> AST
runParser filename ts = case parse program filename ts of
                             Right a -> a
                             Left _ -> Failure
